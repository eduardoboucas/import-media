////
/// Parsing engine
/// @author Hugo Giraudel
/// @access private
////

///
/// Get operator of an expression
///
/// @param {String} $expression - Expression to extract operator from
///
/// @return {String} - Any of `>=`, `>`, `<=`, `<`, `≥`, `≤`
///
@function get-expression-operator($expression) {
  @each $operator in ('>=', '>', '<=', '<', '≥', '≤') {
    @if str-index($expression, $operator) {
      @return $operator;
    }
  }

  // It is not possible to include a mixin inside a function, so we have to
  // rely on the `log(..)` function rather than the `log(..)` mixin. Because
  // functions cannot be called anywhere in Sass, we need to hack the call in
  // a dummy variable, such as `$_`. If anybody ever raise a scoping issue with
  // Sass 3.3, change this line in `@if log(..) {}` instead.
  $_: log('No operator found in `#{$expression}`.');
}

///
/// Get dimension of an expression, based on a found operator
///
/// @param {String} $expression - Expression to extract dimension from
/// @param {String} $operator - Operator from `$expression`
///
/// @return {String} - `width` or `height` (or potentially anything else)
///
@function get-expression-dimension($expression, $operator) {
  $operator-index: str-index($expression, $operator);
  $parsed-dimension: str-slice($expression, 0, $operator-index - 1);
  $dimension: 'width';

  @if str-length($parsed-dimension) > 0 {
    $dimension: $parsed-dimension;
  }

  @return $dimension;
}

///
/// Get dimension prefix based on an operator
///
/// @param {String} $operator - Operator
///
/// @return {String} - `min` or `max`
///
@function get-expression-prefix($operator) {
  @return if(index(('<', '<=', '≤'), $operator), 'max', 'min');
}

///
/// Get value of an expression, based on a found operator
///
/// @param {String} $expression - Expression to extract value from
/// @param {String} $operator - Operator from `$expression`
///
/// @return {Number} - A numeric value
///
@function get-expression-value($expression, $operator) {
  $operator-index: str-index($expression, $operator);
  $value: str-slice($expression, $operator-index + str-length($operator));

  @if map-has-key($breakpoints, $value) {
    $value: map-get($breakpoints, $value);
  } @else {
    $value: to-number($value);
  }

  $interval: map-get($unit-intervals, unit($value));

  @if not $interval {
    // It is not possible to include a mixin inside a function, so we have to
    // rely on the `log(..)` function rather than the `log(..)` mixin. Because
    // functions cannot be called anywhere in Sass, we need to hack the call in
    // a dummy variable, such as `$_`. If anybody ever raise a scoping issue with
    // Sass 3.3, change this line in `@if log(..) {}` instead.
    $_: log('Unknown unit `#{unit($value)}`.');
  }

  @if $operator == '>' {
    $value: $value + $interval;
  } @else if $operator == '<' {
    $value: $value - $interval;
  }

  @return $value;
}

///
/// TODO: Documentation
///
/// @param {String} $feature-queries - (TODO: documentation)
///
/// @return {String} - (TODO: documentation)
///
@function chain-feature-queries($feature-queries, $do-parse: true) {
  $separator: list-separator($feature-queries);
  $parsed-feature-queries: if($separator == 'comma', (), ((),));

  @each $query in $feature-queries {
    $new-parsed-feature-queries: ();

    @if (type-of($query) == 'list') {
      // List item is a list itself
      $intermediary-queries: chain-feature-queries($query); // Returns a nested list in the form: ((a b), (c))

      @if ($separator == 'space') {
        @each $intermediary-query in $intermediary-queries {
          @each $parsed-feature-query in $parsed-feature-queries {
            $parsed-feature-query: join($parsed-feature-query, $intermediary-query, $separator);
            $new-parsed-feature-queries: append($new-parsed-feature-queries, $parsed-feature-query, 'comma');
          }
        }
      } @else {
        $new-parsed-feature-queries: $parsed-feature-queries;

        @each $intermediary-query in $intermediary-queries {
          $new-parsed-feature-queries: append($new-parsed-feature-queries, $intermediary-query, 'comma');
        }
      }
    } @else {
      // List item is a string
      $parsed-current-query: if($do-parse, parse-expression($query), $query);

      @if (type-of($parsed-current-query) == 'list') {
        // Parsed expression is a list
        $intermediary-queries: chain-feature-queries($parsed-current-query, false);
        $new-parsed-feature-queries: append-feature-query($parsed-feature-queries, $intermediary-queries, $separator);

        //@if ($separator == 'space') {
        //  @each $intermediary-query in $intermediary-queries {
        //    @each $parsed-feature-query in $parsed-feature-queries {
        //      $parsed-feature-query: append($parsed-feature-query, $intermediary-query, $separator);
        //      $new-parsed-feature-queries: append($new-parsed-feature-queries, $parsed-feature-query, 'comma');
        //    }
        //  }
        //} @else {
        //  $new-parsed-feature-queries: $parsed-feature-queries;
        //
        //  @each $intermediary-query in $intermediary-queries {
        //    $new-parsed-feature-queries: append($new-parsed-feature-queries, $intermediary-query, 'comma');
        //  }
        //}
      } @else {
        // Parsed expression is a string
        $intermediary-queries: ($parsed-current-query);
        $new-parsed-feature-queries: append-feature-query($parsed-feature-queries, $intermediary-queries, $separator);

        //@if ($separator == 'space') {
        //  @each $intermediary-query in $intermediary-queries {
        //    @each $parsed-feature-query in $parsed-feature-queries {
        //      $parsed-feature-query: append($parsed-feature-query, $intermediary-query, $separator);
        //      $new-parsed-feature-queries: append($new-parsed-feature-queries, $parsed-feature-query, 'comma');
        //    }
        //  }
        //} @else {
        //  $new-parsed-feature-queries: $parsed-feature-queries;
        //
        //  @each $intermediary-query in $intermediary-queries {
        //    $new-parsed-feature-queries: append($new-parsed-feature-queries, $intermediary-query, 'comma');
        //  }
        //}
      }

    }

    $parsed-feature-queries: $new-parsed-feature-queries;
  }

  @return $parsed-feature-queries;
}

///
/// TODO: Documentation
///
@function append-feature-query($parent-queries, $child-queries, $separator) {
  $result: if($separator == 'space', (), $parent-queries);

  @if ($separator == 'space') {
    // Logical AND
    @each $child-query in $child-queries {
      @each $parent-query in $parent-queries {
        $q: append($parent-query, $child-query, $separator);
        $result: append($result, $q, 'comma');
      }
    }
  } @else {
    // Logical OR
    @each $child-query in $child-queries {
      $result: append($result, $child-query, 'comma');
    }
  }

  @return $result;
}

///
/// Parse an expression to return a valid media-query expression
///
/// @param {String} $expression - Expression to parse
///
/// @return {String} - Valid media query
///
@function parse-expression($expression) {
  // If it is part of $media-expressions, it has no operator
  // then there is no need to go any further, just return the value
  @if map-has-key($media-expressions, $expression) {
    @return map-get($media-expressions, $expression);
  }

  $operator: get-expression-operator($expression);
  $dimension: get-expression-dimension($expression, $operator);
  $prefix: get-expression-prefix($operator);
  $value: get-expression-value($expression, $operator);

  @return '(#{$prefix}-#{$dimension}: #{$value})';
}
